<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HWDG: HWDG::Operations Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HWDG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_h_w_d_g.html">HWDG</a></li><li class="navelem"><a class="el" href="class_h_w_d_g_1_1_operations.html">Operations</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_h_w_d_g_1_1_operations-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">HWDG::Operations Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Static class containing operations (algorithms) to be performed on graphs.  
 <a href="class_h_w_d_g_1_1_operations.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="operations_8hpp_source.html">operations.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8350677ac072f2ebec03627cc55f2581"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a8350677ac072f2ebec03627cc55f2581">Operations</a> ()=delete</td></tr>
<tr class="separator:a8350677ac072f2ebec03627cc55f2581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5b76b30fb9c0d465be47c98bb85605a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a5b76b30fb9c0d465be47c98bb85605a3">Union</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:a5b76b30fb9c0d465be47c98bb85605a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union with edge-weight addition.  <a href="class_h_w_d_g_1_1_operations.html#a5b76b30fb9c0d465be47c98bb85605a3">More...</a><br /></td></tr>
<tr class="separator:a5b76b30fb9c0d465be47c98bb85605a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a69191f00a4847c5876fe6e427cee08"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a8a69191f00a4847c5876fe6e427cee08">Union</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b, float balancer)</td></tr>
<tr class="memdesc:a8a69191f00a4847c5876fe6e427cee08"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union with edge-weight balancer.  <a href="class_h_w_d_g_1_1_operations.html#a8a69191f00a4847c5876fe6e427cee08">More...</a><br /></td></tr>
<tr class="separator:a8a69191f00a4847c5876fe6e427cee08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd95f315ec558a93e723120f759c681"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#adfd95f315ec558a93e723120f759c681">MergeUnion</a> (<a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:adfd95f315ec558a93e723120f759c681"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union in place, with edge-weight addition.  <a href="class_h_w_d_g_1_1_operations.html#adfd95f315ec558a93e723120f759c681">More...</a><br /></td></tr>
<tr class="separator:adfd95f315ec558a93e723120f759c681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2eeb1a194d061893f9d543257003e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a2e2eeb1a194d061893f9d543257003e4">MergeUnion</a> (<a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b, float balancer)</td></tr>
<tr class="memdesc:a2e2eeb1a194d061893f9d543257003e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union in place, with edge-weight balancer.  <a href="class_h_w_d_g_1_1_operations.html#a2e2eeb1a194d061893f9d543257003e4">More...</a><br /></td></tr>
<tr class="separator:a2e2eeb1a194d061893f9d543257003e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d684bf29238a8b33baf8a84518d115"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a62d684bf29238a8b33baf8a84518d115">Intersection</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b, float balancer)</td></tr>
<tr class="memdesc:a62d684bf29238a8b33baf8a84518d115"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> intersection, with edge-weight balancer.  <a href="class_h_w_d_g_1_1_operations.html#a62d684bf29238a8b33baf8a84518d115">More...</a><br /></td></tr>
<tr class="separator:a62d684bf29238a8b33baf8a84518d115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886c28ca88d1454bc2a32f2e38d8ce28"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a886c28ca88d1454bc2a32f2e38d8ce28">InverseIntersection</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:a886c28ca88d1454bc2a32f2e38d8ce28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of intersection.  <a href="class_h_w_d_g_1_1_operations.html#a886c28ca88d1454bc2a32f2e38d8ce28">More...</a><br /></td></tr>
<tr class="separator:a886c28ca88d1454bc2a32f2e38d8ce28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b14056c01f4761761357aa368c1b42d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a8b14056c01f4761761357aa368c1b42d">Difference</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:a8b14056c01f4761761357aa368c1b42d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> difference.  <a href="class_h_w_d_g_1_1_operations.html#a8b14056c01f4761761357aa368c1b42d">More...</a><br /></td></tr>
<tr class="separator:a8b14056c01f4761761357aa368c1b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7212a62d594606cb78a7846e9cd61d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a5b7212a62d594606cb78a7846e9cd61d">ContainmentSimilarity</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:a5b7212a62d594606cb78a7846e9cd61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Containment Similarity (CS) comparison of graphs.  <a href="class_h_w_d_g_1_1_operations.html#a5b7212a62d594606cb78a7846e9cd61d">More...</a><br /></td></tr>
<tr class="separator:a5b7212a62d594606cb78a7846e9cd61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6254cbedd5184b7dabb9bc44ab0e426c"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a6254cbedd5184b7dabb9bc44ab0e426c">SizeSimilarity</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:a6254cbedd5184b7dabb9bc44ab0e426c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size Similarity (SS) comparison of graphs.  <a href="class_h_w_d_g_1_1_operations.html#a6254cbedd5184b7dabb9bc44ab0e426c">More...</a><br /></td></tr>
<tr class="separator:a6254cbedd5184b7dabb9bc44ab0e426c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10780f76c6b92c35c439895efab89f8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#aa10780f76c6b92c35c439895efab89f8">ValueSimilarity</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:aa10780f76c6b92c35c439895efab89f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value Similarity (VS) comparison of graphs.  <a href="class_h_w_d_g_1_1_operations.html#aa10780f76c6b92c35c439895efab89f8">More...</a><br /></td></tr>
<tr class="separator:aa10780f76c6b92c35c439895efab89f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a59807f4e41b116c1c21ab8ef44fe3"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#af2a59807f4e41b116c1c21ab8ef44fe3">NormalizedValueSimilarity</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:af2a59807f4e41b116c1c21ab8ef44fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized Value Similarity (NVS) comparison of graphs.  <a href="class_h_w_d_g_1_1_operations.html#af2a59807f4e41b116c1c21ab8ef44fe3">More...</a><br /></td></tr>
<tr class="separator:af2a59807f4e41b116c1c21ab8ef44fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b108d9c6bcffc02d9c3e2a91830416"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a07b108d9c6bcffc02d9c3e2a91830416">BreadthFirstSearch</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;graph, const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;starting_node, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; func)</td></tr>
<tr class="memdesc:a07b108d9c6bcffc02d9c3e2a91830416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth First Search (BFS) of graph.  <a href="class_h_w_d_g_1_1_operations.html#a07b108d9c6bcffc02d9c3e2a91830416">More...</a><br /></td></tr>
<tr class="separator:a07b108d9c6bcffc02d9c3e2a91830416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c734f9e26b76d1ac5d46e846c49784"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a46c734f9e26b76d1ac5d46e846c49784">BreadthFirstSearch</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;graph, const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;starting_node, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; func, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_node_in_graph.html">NodeInGraph</a> &amp;node, std::vector&lt; <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &gt; &amp;to_be_traversed_first, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; priority)</td></tr>
<tr class="memdesc:a46c734f9e26b76d1ac5d46e846c49784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth First Search (BFS) of graph.  <a href="class_h_w_d_g_1_1_operations.html#a46c734f9e26b76d1ac5d46e846c49784">More...</a><br /></td></tr>
<tr class="separator:a46c734f9e26b76d1ac5d46e846c49784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7f356eb128ecb53c608b66ed6cc37a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a0b7f356eb128ecb53c608b66ed6cc37a">DepthFirstSearch</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;graph, const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;starting_node, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; func)</td></tr>
<tr class="memdesc:a0b7f356eb128ecb53c608b66ed6cc37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth First Search (DFS) of graph.  <a href="class_h_w_d_g_1_1_operations.html#a0b7f356eb128ecb53c608b66ed6cc37a">More...</a><br /></td></tr>
<tr class="separator:a0b7f356eb128ecb53c608b66ed6cc37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc53828b581595b6796e76444e4f070"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_operations.html#a2bc53828b581595b6796e76444e4f070">DepthFirstSearch</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;graph, const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;starting_node, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; func, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_node_in_graph.html">NodeInGraph</a> &amp;node, std::vector&lt; <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &gt; &amp;to_be_traversed_first, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; priority)</td></tr>
<tr class="memdesc:a2bc53828b581595b6796e76444e4f070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth First Search (DFS) of graph.  <a href="class_h_w_d_g_1_1_operations.html#a2bc53828b581595b6796e76444e4f070">More...</a><br /></td></tr>
<tr class="separator:a2bc53828b581595b6796e76444e4f070"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Static class containing operations (algorithms) to be performed on graphs. </p>
<p >This is static class, so you can't create instances (objects) of it, and all methods are static member function. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8350677ac072f2ebec03627cc55f2581" name="a8350677ac072f2ebec03627cc55f2581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8350677ac072f2ebec03627cc55f2581">&#9670;&nbsp;</a></span>Operations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HWDG::Operations::Operations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a07b108d9c6bcffc02d9c3e2a91830416" name="a07b108d9c6bcffc02d9c3e2a91830416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b108d9c6bcffc02d9c3e2a91830416">&#9670;&nbsp;</a></span>BreadthFirstSearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HWDG::Operations::BreadthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Breadth First Search (BFS) of graph. </p>
<p >BFS traverses graph's nodes in such a way that each <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> is visited only once and with minimal number of traversals (weight isn't considered here, only number of traversals)</p>
<p >It starts at starting node and adds all of its neightbours before into to-be-visited queue. Then the same is done to each element in the queue. However if neighbour was visited already or is currently in queue, then it's ignored. Note that all of neighbours of <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> are added into queue, but they're not processed immediately. It's FIFO queue.</p>
<p >Sequence of neighbours in FIFO queue is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> to be traversed, </td></tr>
    <tr><td class="paramname">starting_node</td><td>Starting <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> from which traversal will happen. </td></tr>
    <tr><td class="paramname">func</td><td>Function (typically lambda expression) that will be called for each <a class="el" href="class_h_w_d_g_1_1_edge.html" title="Edge pointing from one Node to another.">Edge</a> that is traversed. Unordered set contains all already visited nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a46c734f9e26b76d1ac5d46e846c49784" name="a46c734f9e26b76d1ac5d46e846c49784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c734f9e26b76d1ac5d46e846c49784">&#9670;&nbsp;</a></span>BreadthFirstSearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HWDG::Operations::BreadthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_node_in_graph.html">NodeInGraph</a> &amp;node, std::vector&lt; <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &gt; &amp;to_be_traversed_first, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Breadth First Search (BFS) of graph. </p>
<p >BFS traverses graph's nodes in such a way that each <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> is visited only once and with minimal number of traversals (weight isn't considered here, only number of traversals)</p>
<p >It starts at starting node and adds all of its neightbours before into to-be-visited queue. Then the same is done to each element in the queue. However if neighbour was visited already or is currently in queue, then it's ignored. Note that all of neighbours of <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> are added into queue, but they're not processed immediately. It's FIFO queue.</p>
<p >Sequence of neighbours in FIFO queue is determined by priority function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> to be traversed, </td></tr>
    <tr><td class="paramname">starting_node</td><td>Starting <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> from which traversal will happen. </td></tr>
    <tr><td class="paramname">func</td><td>Function (typically lambda expression) that will be called for each <a class="el" href="class_h_w_d_g_1_1_edge.html" title="Edge pointing from one Node to another.">Edge</a> that is traversed. Unordered set contains all already visited nodes. </td></tr>
    <tr><td class="paramname">priority</td><td>Function (typically lambda expression) that decides on sequence in which nodes are visited. This function MUST add all neighbours into parameter 'to_be_traversed_first', then to_be_traversed_first.front() will be visited first and to_be_traversed_first.back() will be visited last. No need to check whether neighbour was visited in the past, overlying algorithm deals with that part on it's own. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a5b7212a62d594606cb78a7846e9cd61d" name="a5b7212a62d594606cb78a7846e9cd61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7212a62d594606cb78a7846e9cd61d">&#9670;&nbsp;</a></span>ContainmentSimilarity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double HWDG::Operations::ContainmentSimilarity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Containment Similarity (CS) comparison of graphs. </p>
<p >Algorithm: \( CS(A,B) = \frac{\sum\nolimits_{e \in A \cap B} 1}{min(|A|,|B|)} \)</p>
<p >where \( |X| \) stands for number of edges in graph X </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of CS algorithm, belongs to [0,1] </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a0b7f356eb128ecb53c608b66ed6cc37a" name="a0b7f356eb128ecb53c608b66ed6cc37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7f356eb128ecb53c608b66ed6cc37a">&#9670;&nbsp;</a></span>DepthFirstSearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HWDG::Operations::DepthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depth First Search (DFS) of graph. </p>
<p >DFS traverses graph's nodes in such a way that each <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> is visited only once.</p>
<p >It starts at starting node and follows one neighbour as deep in graph as possible before moving on to next neighbour. Next neighbours to follow are chosen arbitrarily, sequence is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> to be traversed, </td></tr>
    <tr><td class="paramname">starting_node</td><td>Starting <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> from which traversal will happen. </td></tr>
    <tr><td class="paramname">func</td><td>Function (typically lambda expression) that will be called for each <a class="el" href="class_h_w_d_g_1_1_edge.html" title="Edge pointing from one Node to another.">Edge</a> that is traversed. Unordered set contains all already visited nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a2bc53828b581595b6796e76444e4f070" name="a2bc53828b581595b6796e76444e4f070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc53828b581595b6796e76444e4f070">&#9670;&nbsp;</a></span>DepthFirstSearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HWDG::Operations::DepthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_node_in_graph.html">NodeInGraph</a> &amp;node, std::vector&lt; <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &gt; &amp;to_be_traversed_first, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depth First Search (DFS) of graph. </p>
<p >DFS traverses graph's nodes in such a way that each <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> is visited only once.</p>
<p >It starts at starting node and follows one neighbour as deep in graph as possible before moving on to next neighbour. Neighbour sequence must be provided by function passed as parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> to be traversed, </td></tr>
    <tr><td class="paramname">starting_node</td><td>Starting <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> from which traversal will happen. </td></tr>
    <tr><td class="paramname">func</td><td>Function (typically lambda expression) that will be called for each <a class="el" href="class_h_w_d_g_1_1_edge.html" title="Edge pointing from one Node to another.">Edge</a> that is traversed. Unordered set contains all already visited nodes. </td></tr>
    <tr><td class="paramname">priority</td><td>Function (typically lambda expression) that decides on sequence in which nodes are visited. This function MUST add all neighbours into parameter 'to_be_traversed_first', then to_be_traversed_first.front() will be visited first and to_be_traversed_first.back() will be visited last. No need to check whether neighbour was visited in the past, overlying algorithm deals with that part on it's own. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a8b14056c01f4761761357aa368c1b42d" name="a8b14056c01f4761761357aa368c1b42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b14056c01f4761761357aa368c1b42d">&#9670;&nbsp;</a></span>Difference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::Operations::Difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> difference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, left-side graph (minuend) that B will be "substracted" from. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, right-side graph (subtrahend) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> consisting of those edges and nodes that belong to A, but NOT to B. </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a62d684bf29238a8b33baf8a84518d115" name="a62d684bf29238a8b33baf8a84518d115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d684bf29238a8b33baf8a84518d115">&#9670;&nbsp;</a></span>Intersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::Operations::Intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>balancer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> intersection, with edge-weight balancer. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} L*w_{e_A} + (1-L) * w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. \(L\) is balancer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, one of component for intersection </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, one of component for intersection </td></tr>
    <tr><td class="paramname">balancer</td><td>Balancing factor used in weight computation. MUST belong to [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> that consists only of nodes and edges that belong to both A and B </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a886c28ca88d1454bc2a32f2e38d8ce28" name="a886c28ca88d1454bc2a32f2e38d8ce28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886c28ca88d1454bc2a32f2e38d8ce28">&#9670;&nbsp;</a></span>InverseIntersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::Operations::InverseIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of intersection. </p>
<p >Returns <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> consisting of nodes and edges that are part of either A or B, but not both at the same time.</p>
<p >Effectively, it is equal to Difference(Union(A,B), Intersection(A,B,dummy)). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, one of component for inverse intersection </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, one of component for inverse intersection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> that consists only of nodes and edges that belong to either A and B, but not both at the same time. </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="adfd95f315ec558a93e723120f759c681" name="adfd95f315ec558a93e723120f759c681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd95f315ec558a93e723120f759c681">&#9670;&nbsp;</a></span>MergeUnion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HWDG::Operations::MergeUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union in place, with edge-weight addition. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} w_{e_A} &amp; \textrm{if $e \in A$ and $e \notin B$}\\ w_{e_B} &amp; \textrm{if $e \notin A$ and $e \in B$}\\ w_{e_A} + w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. \(L\) is balancer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, to which <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B will be added. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, that will be added to A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a2e2eeb1a194d061893f9d543257003e4" name="a2e2eeb1a194d061893f9d543257003e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2eeb1a194d061893f9d543257003e4">&#9670;&nbsp;</a></span>MergeUnion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void HWDG::Operations::MergeUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>balancer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union in place, with edge-weight balancer. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} w_{e_A} &amp; \textrm{if $e \in A$ and $e \notin B$}\\ w_{e_B} &amp; \textrm{if $e \notin A$ and $e \in B$}\\ L*w_{e_A} + (1-L) * w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. \(L\) is balancer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, to which <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B will be added. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, that will be added to A. </td></tr>
    <tr><td class="paramname">balancer</td><td>Balancing factor used in weight computation. MUST belong to [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="af2a59807f4e41b116c1c21ab8ef44fe3" name="af2a59807f4e41b116c1c21ab8ef44fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a59807f4e41b116c1c21ab8ef44fe3">&#9670;&nbsp;</a></span>NormalizedValueSimilarity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double HWDG::Operations::NormalizedValueSimilarity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalized Value Similarity (NVS) comparison of graphs. </p>
<p >Ignores the relative sizes of the compared graphs and focuses on the weights of common edges.</p>
<p >Algorithm: \( NVS(A,B) = \frac{VS(A,B)}{SS(A,B)} \)</p>
<p >Check <a class="el" href="class_h_w_d_g_1_1_operations.html#aa10780f76c6b92c35c439895efab89f8" title="Value Similarity (VS) comparison of graphs.">ValueSimilarity()</a> and <a class="el" href="class_h_w_d_g_1_1_operations.html#a6254cbedd5184b7dabb9bc44ab0e426c" title="Size Similarity (SS) comparison of graphs.">SizeSimilarity()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of NVS algorithm </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a6254cbedd5184b7dabb9bc44ab0e426c" name="a6254cbedd5184b7dabb9bc44ab0e426c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6254cbedd5184b7dabb9bc44ab0e426c">&#9670;&nbsp;</a></span>SizeSimilarity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double HWDG::Operations::SizeSimilarity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size Similarity (SS) comparison of graphs. </p>
<p >Algorithm: \( SS(A,B) = \frac{min(|A|,|B|)}{max(|A|,|B|)} \)</p>
<p >where \( |X| \) stands for number of edges in graph X </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of SS algorithm, belongs to [0,1] </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(1)\) </dd></dl>

</div>
</div>
<a id="a5b76b30fb9c0d465be47c98bb85605a3" name="a5b76b30fb9c0d465be47c98bb85605a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b76b30fb9c0d465be47c98bb85605a3">&#9670;&nbsp;</a></span>Union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::Operations::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union with edge-weight addition. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} w_{e_A} &amp; \textrm{if $e \in A$ and $e \notin B$}\\ w_{e_B} &amp; \textrm{if $e \notin A$ and $e \in B$}\\ w_{e_A} + w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, one of components for union (sum) </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, one of components for union (sum) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> consisting of all nodes and edges existing in either a or b, with weight computed by algorithm. </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a8a69191f00a4847c5876fe6e427cee08" name="a8a69191f00a4847c5876fe6e427cee08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a69191f00a4847c5876fe6e427cee08">&#9670;&nbsp;</a></span>Union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::Operations::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>balancer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union with edge-weight balancer. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} w_{e_A} &amp; \textrm{if $e \in A$ and $e \notin B$}\\ w_{e_B} &amp; \textrm{if $e \notin A$ and $e \in B$}\\ L*w_{e_A} + (1-L) * w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. \(L\) is balancer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, one of components for union (sum) </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, one of components for union (sum) </td></tr>
    <tr><td class="paramname">balancer</td><td>Balancing factor used in weight computation. MUST belong to [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> consisting of all nodes and edges existing in either a or b, with weight computed by algorithm. </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="aa10780f76c6b92c35c439895efab89f8" name="aa10780f76c6b92c35c439895efab89f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10780f76c6b92c35c439895efab89f8">&#9670;&nbsp;</a></span>ValueSimilarity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double HWDG::Operations::ValueSimilarity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value Similarity (VS) comparison of graphs. </p>
<p >Algorithm: \( VS(A,B) = \frac{\sum\nolimits_{e \in A \cap B} \frac { min(w_{e_A}, w_{e_B}) } { max(w_{e_A}, w_{e_B}) }} {max(|A|,|B|)} \)</p>
<p >where \( |X| \) stands for number of edges in graph X, and \( w_{e_X} \) is 'weight' of edge 'e' in graph 'x' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of VS algorithm, belongs to [0,1] </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="operations_8hpp_source.html">operations.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
