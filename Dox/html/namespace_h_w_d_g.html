<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HWDG: HWDG Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HWDG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">HWDG Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main namespace of library.  
<a href="namespace_h_w_d_g.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_h_w_d_g_1_1_map"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g_1_1_map.html">Map</a></td></tr>
<tr class="memdesc:namespace_h_w_d_g_1_1_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for map wrappers, cause i couldn't make it work any other way. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_bellman_ford.html">BellmanFord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static class implementing Bellman-Ford algorithm for pathfinding.  <a href="class_h_w_d_g_1_1_bellman_ford.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_dijkstra.html">Dijkstra</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static class implementing <a class="el" href="class_h_w_d_g_1_1_dijkstra.html" title="Static class implementing Dijkstra algorithm for pathfinding.">Dijkstra</a> algorithm for pathfinding.  <a href="class_h_w_d_g_1_1_dijkstra.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_edge.html" title="Edge pointing from one Node to another.">Edge</a> pointing from one <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> to another.  <a href="class_h_w_d_g_1_1_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a>.  <a href="class_h_w_d_g_1_1_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of node (vertex) outside of <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> context.  <a href="class_h_w_d_g_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_node_in_graph.html">NodeInGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of node/vertex inside <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a>'s context.  <a href="class_h_w_d_g_1_1_node_in_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_w_d_g_1_1_path.html">Path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level class to extract <a class="el" href="class_h_w_d_g_1_1_path.html" title="High-level class to extract Path from Pathtable.">Path</a> from <a class="el" href="struct_h_w_d_g_1_1_pathtable.html" title="Thin wrapper for std::unordered_map.">Pathtable</a>.  <a href="class_h_w_d_g_1_1_path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_w_d_g_1_1_pathtable.html">Pathtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin wrapper for std::unordered_map.  <a href="struct_h_w_d_g_1_1_pathtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_w_d_g_1_1_pathtable_cell.html">PathtableCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level, cell within <a class="el" href="struct_h_w_d_g_1_1_pathtable.html" title="Thin wrapper for std::unordered_map.">Pathtable</a>, representing previous <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> in path, and weight of path to this point.  <a href="struct_h_w_d_g_1_1_pathtable_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b06bdef049ccd691a8a41af2b522b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a0b06bdef049ccd691a8a41af2b522b5b">Union</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:a0b06bdef049ccd691a8a41af2b522b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union with edge-weight addition.  <a href="namespace_h_w_d_g.html#a0b06bdef049ccd691a8a41af2b522b5b">More...</a><br /></td></tr>
<tr class="separator:a0b06bdef049ccd691a8a41af2b522b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89e6a205715814ea2345613f2146754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#ac89e6a205715814ea2345613f2146754">Union</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b, float balancer)</td></tr>
<tr class="memdesc:ac89e6a205715814ea2345613f2146754"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union with edge-weight balancer.  <a href="namespace_h_w_d_g.html#ac89e6a205715814ea2345613f2146754">More...</a><br /></td></tr>
<tr class="separator:ac89e6a205715814ea2345613f2146754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de275cd8674b0f40a4922e78e9dbe5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a9de275cd8674b0f40a4922e78e9dbe5e">MergeUnion</a> (<a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:a9de275cd8674b0f40a4922e78e9dbe5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union in place, with edge-weight addition.  <a href="namespace_h_w_d_g.html#a9de275cd8674b0f40a4922e78e9dbe5e">More...</a><br /></td></tr>
<tr class="separator:a9de275cd8674b0f40a4922e78e9dbe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55adce6f32b5d8add6711e13a3836eae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a55adce6f32b5d8add6711e13a3836eae">MergeUnion</a> (<a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b, float balancer)</td></tr>
<tr class="memdesc:a55adce6f32b5d8add6711e13a3836eae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union in place, with edge-weight balancer.  <a href="namespace_h_w_d_g.html#a55adce6f32b5d8add6711e13a3836eae">More...</a><br /></td></tr>
<tr class="separator:a55adce6f32b5d8add6711e13a3836eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafead500d6026f1499032f262197c310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#aafead500d6026f1499032f262197c310">Intersection</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b, float balancer)</td></tr>
<tr class="memdesc:aafead500d6026f1499032f262197c310"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> intersection, with edge-weight balancer.  <a href="namespace_h_w_d_g.html#aafead500d6026f1499032f262197c310">More...</a><br /></td></tr>
<tr class="separator:aafead500d6026f1499032f262197c310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09ee4fd698afa0ba35776995107e901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#ab09ee4fd698afa0ba35776995107e901">InverseIntersection</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:ab09ee4fd698afa0ba35776995107e901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of intersection.  <a href="namespace_h_w_d_g.html#ab09ee4fd698afa0ba35776995107e901">More...</a><br /></td></tr>
<tr class="separator:ab09ee4fd698afa0ba35776995107e901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa895103af42872e5ae26c196b79bae56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#aa895103af42872e5ae26c196b79bae56">Difference</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:aa895103af42872e5ae26c196b79bae56"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> difference.  <a href="namespace_h_w_d_g.html#aa895103af42872e5ae26c196b79bae56">More...</a><br /></td></tr>
<tr class="separator:aa895103af42872e5ae26c196b79bae56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00aa26baf287208240bc06920840a152"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a00aa26baf287208240bc06920840a152">ContainmentSimilarity</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:a00aa26baf287208240bc06920840a152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Containment Similarity (CS) comparison of graphs.  <a href="namespace_h_w_d_g.html#a00aa26baf287208240bc06920840a152">More...</a><br /></td></tr>
<tr class="separator:a00aa26baf287208240bc06920840a152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0200f754ed3aa030eacdc3b73feb74"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#aae0200f754ed3aa030eacdc3b73feb74">SizeSimilarity</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:aae0200f754ed3aa030eacdc3b73feb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size Similarity (SS) comparison of graphs.  <a href="namespace_h_w_d_g.html#aae0200f754ed3aa030eacdc3b73feb74">More...</a><br /></td></tr>
<tr class="separator:aae0200f754ed3aa030eacdc3b73feb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae850d0eed271330ca57f14c63b3e0835"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#ae850d0eed271330ca57f14c63b3e0835">ValueSimilarity</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:ae850d0eed271330ca57f14c63b3e0835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value Similarity (VS) comparison of graphs.  <a href="namespace_h_w_d_g.html#ae850d0eed271330ca57f14c63b3e0835">More...</a><br /></td></tr>
<tr class="separator:ae850d0eed271330ca57f14c63b3e0835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a88c623e5e25a111bc898113d4b6118"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a2a88c623e5e25a111bc898113d4b6118">NormalizedValueSimilarity</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;a, const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;b)</td></tr>
<tr class="memdesc:a2a88c623e5e25a111bc898113d4b6118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized Value Similarity (NVS) comparison of graphs.  <a href="namespace_h_w_d_g.html#a2a88c623e5e25a111bc898113d4b6118">More...</a><br /></td></tr>
<tr class="separator:a2a88c623e5e25a111bc898113d4b6118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1335e550ac012515e07da6f8009032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a7b1335e550ac012515e07da6f8009032">BreadthFirstSearch</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;graph, const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;starting_node, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; func)</td></tr>
<tr class="memdesc:a7b1335e550ac012515e07da6f8009032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth First Search (BFS) of graph.  <a href="namespace_h_w_d_g.html#a7b1335e550ac012515e07da6f8009032">More...</a><br /></td></tr>
<tr class="separator:a7b1335e550ac012515e07da6f8009032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8035c89d0bca2c6c712e2670633ce4a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a8035c89d0bca2c6c712e2670633ce4a7">BreadthFirstSearch</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;graph, const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;starting_node, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; func, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_node_in_graph.html">NodeInGraph</a> &amp;node, std::vector&lt; <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &gt; &amp;to_be_traversed_first, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; priority)</td></tr>
<tr class="memdesc:a8035c89d0bca2c6c712e2670633ce4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth First Search (BFS) of graph.  <a href="namespace_h_w_d_g.html#a8035c89d0bca2c6c712e2670633ce4a7">More...</a><br /></td></tr>
<tr class="separator:a8035c89d0bca2c6c712e2670633ce4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1397d769f1f4c8b17b46702eabc332fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a1397d769f1f4c8b17b46702eabc332fe">DepthFirstSearch</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;graph, const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;starting_node, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; func)</td></tr>
<tr class="memdesc:a1397d769f1f4c8b17b46702eabc332fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth First Search (DFS) of graph.  <a href="namespace_h_w_d_g.html#a1397d769f1f4c8b17b46702eabc332fe">More...</a><br /></td></tr>
<tr class="separator:a1397d769f1f4c8b17b46702eabc332fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815cdec3c755b0532a66d40c506da107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a815cdec3c755b0532a66d40c506da107">DepthFirstSearch</a> (const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;graph, const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;starting_node, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; func, std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_node_in_graph.html">NodeInGraph</a> &amp;node, std::vector&lt; <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &gt; &amp;to_be_traversed_first, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt; priority)</td></tr>
<tr class="memdesc:a815cdec3c755b0532a66d40c506da107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth First Search (DFS) of graph.  <a href="namespace_h_w_d_g.html#a815cdec3c755b0532a66d40c506da107">More...</a><br /></td></tr>
<tr class="separator:a815cdec3c755b0532a66d40c506da107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d21a74dbf5fe6c5d0821d2f9b9976ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a2d21a74dbf5fe6c5d0821d2f9b9976ef">RandomGraph</a> (size_t size, float density, float weight_min, float weight_max, bool loops)</td></tr>
<tr class="memdesc:a2d21a74dbf5fe6c5d0821d2f9b9976ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates random graph.  <a href="namespace_h_w_d_g.html#a2d21a74dbf5fe6c5d0821d2f9b9976ef">More...</a><br /></td></tr>
<tr class="separator:a2d21a74dbf5fe6c5d0821d2f9b9976ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f61f18f4074f408c1c853a51054c925"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a2f61f18f4074f408c1c853a51054c925">RandomLowDensityGraph</a> (size_t size, float density, float weight_min, float weight_max, bool loops)</td></tr>
<tr class="memdesc:a2f61f18f4074f408c1c853a51054c925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates random graph.  <a href="namespace_h_w_d_g.html#a2f61f18f4074f408c1c853a51054c925">More...</a><br /></td></tr>
<tr class="separator:a2f61f18f4074f408c1c853a51054c925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e3c48717069c9966704007b404c3ce"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a72e3c48717069c9966704007b404c3ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a72e3c48717069c9966704007b404c3ce">SaveBin</a> (const TYPE &amp;obj, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a72e3c48717069c9966704007b404c3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save object to file in binary mode.  <a href="namespace_h_w_d_g.html#a72e3c48717069c9966704007b404c3ce">More...</a><br /></td></tr>
<tr class="separator:a72e3c48717069c9966704007b404c3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68635147a3ea51445f7135b194f40506"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a68635147a3ea51445f7135b194f40506"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#a68635147a3ea51445f7135b194f40506">LoadBin</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a68635147a3ea51445f7135b194f40506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load object from file in binary mode.  <a href="namespace_h_w_d_g.html#a68635147a3ea51445f7135b194f40506">More...</a><br /></td></tr>
<tr class="separator:a68635147a3ea51445f7135b194f40506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed54e86d592f3e74b07a4d3d8b602e8c"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:aed54e86d592f3e74b07a4d3d8b602e8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#aed54e86d592f3e74b07a4d3d8b602e8c">SaveTxt</a> (const TYPE &amp;obj, const std::string &amp;filename)</td></tr>
<tr class="memdesc:aed54e86d592f3e74b07a4d3d8b602e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save object to file in text mode.  <a href="namespace_h_w_d_g.html#aed54e86d592f3e74b07a4d3d8b602e8c">More...</a><br /></td></tr>
<tr class="separator:aed54e86d592f3e74b07a4d3d8b602e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab908ab18cd038439108689003e4e5389"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:ab908ab18cd038439108689003e4e5389"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_h_w_d_g.html#ab908ab18cd038439108689003e4e5389">LoadTxt</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:ab908ab18cd038439108689003e4e5389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load object from file in text mode.  <a href="namespace_h_w_d_g.html#ab908ab18cd038439108689003e4e5389">More...</a><br /></td></tr>
<tr class="separator:ab908ab18cd038439108689003e4e5389"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Main namespace of library. </p>
<p >All classes and functions belong to this namespace, so it doesn't overlap with your code with any capacity. You can use "using namespace HWDG" if you wish so. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7b1335e550ac012515e07da6f8009032" name="a7b1335e550ac012515e07da6f8009032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1335e550ac012515e07da6f8009032">&#9670;&nbsp;</a></span>BreadthFirstSearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWDG::BreadthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breadth First Search (BFS) of graph. </p>
<p >BFS traverses graph's nodes in such a way that each <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> is visited only once and with minimal number of traversals (weight isn't considered here, only number of traversals)</p>
<p >It starts at starting node and adds all of its neightbours before into to-be-visited queue. Then the same is done to each element in the queue. However if neighbour was visited already or is currently in queue, then it's ignored. Note that all of neighbours of <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> are added into queue, but they're not processed immediately. It's FIFO queue.</p>
<p >Sequence of neighbours in FIFO queue is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> to be traversed, </td></tr>
    <tr><td class="paramname">starting_node</td><td>Starting <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> from which traversal will happen. </td></tr>
    <tr><td class="paramname">func</td><td>Function (typically lambda expression) that will be called for each <a class="el" href="class_h_w_d_g_1_1_edge.html" title="Edge pointing from one Node to another.">Edge</a> that is traversed. Unordered set contains all already visited nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a8035c89d0bca2c6c712e2670633ce4a7" name="a8035c89d0bca2c6c712e2670633ce4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8035c89d0bca2c6c712e2670633ce4a7">&#9670;&nbsp;</a></span>BreadthFirstSearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWDG::BreadthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_node_in_graph.html">NodeInGraph</a> &amp;node, std::vector&lt; <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &gt; &amp;to_be_traversed_first, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breadth First Search (BFS) of graph. </p>
<p >BFS traverses graph's nodes in such a way that each <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> is visited only once and with minimal number of traversals (weight isn't considered here, only number of traversals)</p>
<p >It starts at starting node and adds all of its neightbours before into to-be-visited queue. Then the same is done to each element in the queue. However if neighbour was visited already or is currently in queue, then it's ignored. Note that all of neighbours of <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> are added into queue, but they're not processed immediately. It's FIFO queue.</p>
<p >Sequence of neighbours in FIFO queue is determined by priority function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> to be traversed, </td></tr>
    <tr><td class="paramname">starting_node</td><td>Starting <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> from which traversal will happen. </td></tr>
    <tr><td class="paramname">func</td><td>Function (typically lambda expression) that will be called for each <a class="el" href="class_h_w_d_g_1_1_edge.html" title="Edge pointing from one Node to another.">Edge</a> that is traversed. Unordered set contains all already visited nodes. </td></tr>
    <tr><td class="paramname">priority</td><td>Function (typically lambda expression) that decides on sequence in which nodes are visited. This function MUST add all neighbours into parameter 'to_be_traversed_first', then to_be_traversed_first.front() will be visited first and to_be_traversed_first.back() will be visited last. No need to check whether neighbour was visited in the past, overlying algorithm deals with that part on it's own. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a00aa26baf287208240bc06920840a152" name="a00aa26baf287208240bc06920840a152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00aa26baf287208240bc06920840a152">&#9670;&nbsp;</a></span>ContainmentSimilarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HWDG::ContainmentSimilarity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Containment Similarity (CS) comparison of graphs. </p>
<p >Algorithm: \( CS(A,B) = \frac{\sum\nolimits_{e \in A \cap B} 1}{min(|A|,|B|)} \)</p>
<p >where \( |X| \) stands for number of edges in graph X </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of CS algorithm, belongs to [0,1] </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a1397d769f1f4c8b17b46702eabc332fe" name="a1397d769f1f4c8b17b46702eabc332fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1397d769f1f4c8b17b46702eabc332fe">&#9670;&nbsp;</a></span>DepthFirstSearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWDG::DepthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Depth First Search (DFS) of graph. </p>
<p >DFS traverses graph's nodes in such a way that each <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> is visited only once.</p>
<p >It starts at starting node and follows one neighbour as deep in graph as possible before moving on to next neighbour. Next neighbours to follow are chosen arbitrarily, sequence is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> to be traversed, </td></tr>
    <tr><td class="paramname">starting_node</td><td>Starting <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> from which traversal will happen. </td></tr>
    <tr><td class="paramname">func</td><td>Function (typically lambda expression) that will be called for each <a class="el" href="class_h_w_d_g_1_1_edge.html" title="Edge pointing from one Node to another.">Edge</a> that is traversed. Unordered set contains all already visited nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a815cdec3c755b0532a66d40c506da107" name="a815cdec3c755b0532a66d40c506da107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815cdec3c755b0532a66d40c506da107">&#9670;&nbsp;</a></span>DepthFirstSearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWDG::DepthFirstSearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &amp;edge, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="class_h_w_d_g_1_1_node_in_graph.html">NodeInGraph</a> &amp;node, std::vector&lt; <a class="el" href="class_h_w_d_g_1_1_edge.html">Edge</a> &gt; &amp;to_be_traversed_first, const std::unordered_set&lt; <a class="el" href="class_h_w_d_g_1_1_node.html">Node</a>, <a class="el" href="struct_h_w_d_g_1_1_node_1_1_hash_function.html">Node::HashFunction</a> &gt; &amp;visited)&gt;&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Depth First Search (DFS) of graph. </p>
<p >DFS traverses graph's nodes in such a way that each <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> is visited only once.</p>
<p >It starts at starting node and follows one neighbour as deep in graph as possible before moving on to next neighbour. Neighbour sequence must be provided by function passed as parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> to be traversed, </td></tr>
    <tr><td class="paramname">starting_node</td><td>Starting <a class="el" href="class_h_w_d_g_1_1_node.html" title="Representation of node (vertex) outside of Graph context.">Node</a> from which traversal will happen. </td></tr>
    <tr><td class="paramname">func</td><td>Function (typically lambda expression) that will be called for each <a class="el" href="class_h_w_d_g_1_1_edge.html" title="Edge pointing from one Node to another.">Edge</a> that is traversed. Unordered set contains all already visited nodes. </td></tr>
    <tr><td class="paramname">priority</td><td>Function (typically lambda expression) that decides on sequence in which nodes are visited. This function MUST add all neighbours into parameter 'to_be_traversed_first', then to_be_traversed_first.front() will be visited first and to_be_traversed_first.back() will be visited last. No need to check whether neighbour was visited in the past, overlying algorithm deals with that part on it's own. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="aa895103af42872e5ae26c196b79bae56" name="aa895103af42872e5ae26c196b79bae56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa895103af42872e5ae26c196b79bae56">&#9670;&nbsp;</a></span>Difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::Difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> difference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, left-side graph (minuend) that B will be "substracted" from. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, right-side graph (subtrahend) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> consisting of those edges and nodes that belong to A, but NOT to B. </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="aafead500d6026f1499032f262197c310" name="aafead500d6026f1499032f262197c310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafead500d6026f1499032f262197c310">&#9670;&nbsp;</a></span>Intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::Intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>balancer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> intersection, with edge-weight balancer. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} L*w_{e_A} + (1-L) * w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. \(L\) is balancer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, one of component for intersection </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, one of component for intersection </td></tr>
    <tr><td class="paramname">balancer</td><td>Balancing factor used in weight computation. MUST belong to [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> that consists only of nodes and edges that belong to both A and B </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="ab09ee4fd698afa0ba35776995107e901" name="ab09ee4fd698afa0ba35776995107e901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09ee4fd698afa0ba35776995107e901">&#9670;&nbsp;</a></span>InverseIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::InverseIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse of intersection. </p>
<p >Returns <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> consisting of nodes and edges that are part of either A or B, but not both at the same time.</p>
<p >Effectively, it is equal to Difference(Union(A,B), Intersection(A,B,dummy)). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, one of component for inverse intersection </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, one of component for inverse intersection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> that consists only of nodes and edges that belong to either A and B, but not both at the same time. </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a68635147a3ea51445f7135b194f40506" name="a68635147a3ea51445f7135b194f40506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68635147a3ea51445f7135b194f40506">&#9670;&nbsp;</a></span>LoadBin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE HWDG::LoadBin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load object from file in binary mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>Type of data you want to save. Must implement static member function <a class="el" href="namespace_h_w_d_g.html#a68635147a3ea51445f7135b194f40506" title="Load object from file in binary mode.">TYPE::LoadBin()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file from which data will be loaded </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::ios_base::failure</td><td>Reading error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity: </dt><dd>\(O(n)\) </dd></dl>

</div>
</div>
<a id="ab908ab18cd038439108689003e4e5389" name="ab908ab18cd038439108689003e4e5389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab908ab18cd038439108689003e4e5389">&#9670;&nbsp;</a></span>LoadTxt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE HWDG::LoadTxt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load object from file in text mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>Type of data you want to save. Must implement static member function <a class="el" href="namespace_h_w_d_g.html#ab908ab18cd038439108689003e4e5389" title="Load object from file in text mode.">TYPE::LoadTxt()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of file from which data will be loaded </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::ios_base::failure</td><td>Reading error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity: </dt><dd>\(O(n)\) </dd></dl>

</div>
</div>
<a id="a9de275cd8674b0f40a4922e78e9dbe5e" name="a9de275cd8674b0f40a4922e78e9dbe5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de275cd8674b0f40a4922e78e9dbe5e">&#9670;&nbsp;</a></span>MergeUnion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWDG::MergeUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union in place, with edge-weight addition. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} w_{e_A} &amp; \textrm{if $e \in A$ and $e \notin B$}\\ w_{e_B} &amp; \textrm{if $e \notin A$ and $e \in B$}\\ w_{e_A} + w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. \(L\) is balancer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, to which <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B will be added. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, that will be added to A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a55adce6f32b5d8add6711e13a3836eae" name="a55adce6f32b5d8add6711e13a3836eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55adce6f32b5d8add6711e13a3836eae">&#9670;&nbsp;</a></span>MergeUnion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HWDG::MergeUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>balancer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union in place, with edge-weight balancer. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} w_{e_A} &amp; \textrm{if $e \in A$ and $e \notin B$}\\ w_{e_B} &amp; \textrm{if $e \notin A$ and $e \in B$}\\ L*w_{e_A} + (1-L) * w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. \(L\) is balancer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, to which <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B will be added. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, that will be added to A. </td></tr>
    <tr><td class="paramname">balancer</td><td>Balancing factor used in weight computation. MUST belong to [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a2a88c623e5e25a111bc898113d4b6118" name="a2a88c623e5e25a111bc898113d4b6118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a88c623e5e25a111bc898113d4b6118">&#9670;&nbsp;</a></span>NormalizedValueSimilarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HWDG::NormalizedValueSimilarity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalized Value Similarity (NVS) comparison of graphs. </p>
<p >Ignores the relative sizes of the compared graphs and focuses on the weights of common edges.</p>
<p >Algorithm: \( NVS(A,B) = \frac{VS(A,B)}{SS(A,B)} \)</p>
<p >Check <a class="el" href="namespace_h_w_d_g.html#ae850d0eed271330ca57f14c63b3e0835" title="Value Similarity (VS) comparison of graphs.">ValueSimilarity()</a> and <a class="el" href="namespace_h_w_d_g.html#aae0200f754ed3aa030eacdc3b73feb74" title="Size Similarity (SS) comparison of graphs.">SizeSimilarity()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of NVS algorithm </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="a2d21a74dbf5fe6c5d0821d2f9b9976ef" name="a2d21a74dbf5fe6c5d0821d2f9b9976ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d21a74dbf5fe6c5d0821d2f9b9976ef">&#9670;&nbsp;</a></span>RandomGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::RandomGraph </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates random graph. </p>
<p >Useful during development, for tests. Value of density in output <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> is roughly equal to the one that was used in function call, but remember it ISN'T guaranteed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of nodes. </td></tr>
    <tr><td class="paramname">density</td><td>Density of graph. Must belong to [0,1] </td></tr>
    <tr><td class="paramname">weight_min</td><td>Minimal weight of edge in graph. </td></tr>
    <tr><td class="paramname">weight_max</td><td>Maximal weight of edge in graph. </td></tr>
    <tr><td class="paramname">loops</td><td>Are loops allowed? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Randomly generated <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a>. </dd></dl>
<dl class="section user"><dt>Time complexity: </dt><dd>\(O(nodes^2)\) </dd></dl>

</div>
</div>
<a id="a2f61f18f4074f408c1c853a51054c925" name="a2f61f18f4074f408c1c853a51054c925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f61f18f4074f408c1c853a51054c925">&#9670;&nbsp;</a></span>RandomLowDensityGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::RandomLowDensityGraph </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates random graph. </p>
<p >Useful during development, for tests. Value of density in output <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> is roughly equal to the one that was used in function call, but remember it ISN'T guaranteed.</p>
<p >This implementation is much faster than <a class="el" href="namespace_h_w_d_g.html#a2d21a74dbf5fe6c5d0821d2f9b9976ef" title="Generates random graph.">RandomGraph()</a> for small density, but much slower for high. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of nodes. </td></tr>
    <tr><td class="paramname">density</td><td>Density of graph. Must belong to [0,1] </td></tr>
    <tr><td class="paramname">weight_min</td><td>Minimal weight of edge in graph. </td></tr>
    <tr><td class="paramname">weight_max</td><td>Maximal weight of edge in graph. </td></tr>
    <tr><td class="paramname">loops</td><td>Are loops allowed? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Randomly generated <a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a>. </dd></dl>
<dl class="section user"><dt>Time complexity: </dt><dd>\(O(nodes^2 * density)\) for small density, otherwise \(O(nodes^3)\) </dd></dl>

</div>
</div>
<a id="a72e3c48717069c9966704007b404c3ce" name="a72e3c48717069c9966704007b404c3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e3c48717069c9966704007b404c3ce">&#9670;&nbsp;</a></span>SaveBin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void HWDG::SaveBin </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save object to file in binary mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>Type of data you want to save. Must implement static member function <a class="el" href="namespace_h_w_d_g.html#a72e3c48717069c9966704007b404c3ce" title="Save object to file in binary mode.">TYPE::SaveBin()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Object to be saved. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of file to which you want to save object to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::ios_base::failure</td><td>Writing to file error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity: </dt><dd>\(O(n)\) </dd></dl>

</div>
</div>
<a id="aed54e86d592f3e74b07a4d3d8b602e8c" name="aed54e86d592f3e74b07a4d3d8b602e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed54e86d592f3e74b07a4d3d8b602e8c">&#9670;&nbsp;</a></span>SaveTxt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void HWDG::SaveTxt </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save object to file in text mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>Type of data you want to save. Must implement static member function <a class="el" href="namespace_h_w_d_g.html#aed54e86d592f3e74b07a4d3d8b602e8c" title="Save object to file in text mode.">TYPE::SaveTxt()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Object to be saved. </td></tr>
    <tr><td class="paramname">filename</td><td>Name of file to which you want to save object to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::ios_base::failure</td><td>Writing to file error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity: </dt><dd>\(O(n)\) </dd></dl>

</div>
</div>
<a id="aae0200f754ed3aa030eacdc3b73feb74" name="aae0200f754ed3aa030eacdc3b73feb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0200f754ed3aa030eacdc3b73feb74">&#9670;&nbsp;</a></span>SizeSimilarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HWDG::SizeSimilarity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size Similarity (SS) comparison of graphs. </p>
<p >Algorithm: \( SS(A,B) = \frac{min(|A|,|B|)}{max(|A|,|B|)} \)</p>
<p >where \( |X| \) stands for number of edges in graph X </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of SS algorithm, belongs to [0,1] </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(1)\) </dd></dl>

</div>
</div>
<a id="a0b06bdef049ccd691a8a41af2b522b5b" name="a0b06bdef049ccd691a8a41af2b522b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b06bdef049ccd691a8a41af2b522b5b">&#9670;&nbsp;</a></span>Union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union with edge-weight addition. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} w_{e_A} &amp; \textrm{if $e \in A$ and $e \notin B$}\\ w_{e_B} &amp; \textrm{if $e \notin A$ and $e \in B$}\\ w_{e_A} + w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, one of components for union (sum) </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, one of components for union (sum) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> consisting of all nodes and edges existing in either a or b, with weight computed by algorithm. </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="ac89e6a205715814ea2345613f2146754" name="ac89e6a205715814ea2345613f2146754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89e6a205715814ea2345613f2146754">&#9670;&nbsp;</a></span>Union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> HWDG::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>balancer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> union with edge-weight balancer. </p>
<p >Algorithm for weight of edge: \( w_{e_{out}} = \left\{ \begin{array}{ll} w_{e_A} &amp; \textrm{if $e \in A$ and $e \notin B$}\\ w_{e_B} &amp; \textrm{if $e \notin A$ and $e \in B$}\\ L*w_{e_A} + (1-L) * w_{e_B} &amp; \textrm{if $ e \in A $ and $ e \in B$} \end{array} \right. \)</p>
<p >where \( w_{e_x} \) stands for 'weight' of edge 'e' in graph 'x'. \(L\) is balancer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A, one of components for union (sum) </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B, one of components for union (sum) </td></tr>
    <tr><td class="paramname">balancer</td><td>Balancing factor used in weight computation. MUST belong to [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> consisting of all nodes and edges existing in either a or b, with weight computed by algorithm. </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
<a id="ae850d0eed271330ca57f14c63b3e0835" name="ae850d0eed271330ca57f14c63b3e0835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae850d0eed271330ca57f14c63b3e0835">&#9670;&nbsp;</a></span>ValueSimilarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HWDG::ValueSimilarity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_w_d_g_1_1_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value Similarity (VS) comparison of graphs. </p>
<p >Algorithm: \( VS(A,B) = \frac{\sum\nolimits_{e \in A \cap B} \frac { min(w_{e_A}, w_{e_B}) } { max(w_{e_A}, w_{e_B}) }} {max(|A|,|B|)} \)</p>
<p >where \( |X| \) stands for number of edges in graph X, and \( w_{e_X} \) is 'weight' of edge 'e' in graph 'x' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> A </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_h_w_d_g_1_1_graph.html" title="Representation of Graph.">Graph</a> B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of VS algorithm, belongs to [0,1] </dd></dl>
<dl class="section user"><dt>Time complexity:</dt><dd>\(O(edges)\) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
