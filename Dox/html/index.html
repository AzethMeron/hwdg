<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HWDG: HWDG - Hashtable–based Weighted Directed Graphs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HWDG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="namespace_h_w_d_g.html" title="Main namespace of library.">HWDG</a> - Hashtable–based Weighted Directed Graphs </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
What is it?</h1>
<p ><a class="el" href="namespace_h_w_d_g.html" title="Main namespace of library.">HWDG</a> is a graph implementation written in C++ with heavy emphasis on time complexity. Internally, it uses unordered maps from STL to store nodes and edges. Because of this, it is very efficient when it comes to adding new nodes/edges, or checking if an edge exists within a graph (constant time complexity for each). The downside of this approach is space-complexity.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
What is Graph? Brief, rudimentary introduction</h1>
<p >Graph is mathematical representation of network and can be used to model numerous systems. Typical application of graph is pathfinding (in other words, finding shortest path between two points on map, for example from town to town) although it can be used in many other fields, personally I've used graphs in my NLP-based thesis.</p>
<p >Once you create graph model of your system, you can perform on it many operations and algorithms defined for graphs, like Union, Intersection and more, in similar fashion to any other mathematical model. Think about it this way: if you create quadratic equation (y=ax+^2+bx+c) that models your system, then you can extract some info about this system by using any mathematical tool, you can find minimal/maximal y or calculate derivative. Similarly, for graphs you can easily find shortest path between two states in network using f.e. Dijkstra algorithm.</p>
<p >This implementation features Weighted Directed Graphs, so Graphs consists of Nodes (also called Vertices in literature) and Edges pointing from Node A to Node B with weight W. Example of such simple graph:</p>
<p ><img src="https://user-images.githubusercontent.com/41695668/170822880-fc0ba747-e863-4aa3-b9a0-b695f782c32e.png" alt="ezgif-1-a456a8853e" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md3"></a>
Features</h1>
<ul>
<li>Graph representation using list of successors (except list is replaced with unordered map)</li>
<li>Serialization of graphs (and most of other types)</li>
<li>Addition of edge, removal or check of existence has constant time complexity.</li>
<li>Heap-based Dijkstra algorithm.</li>
<li>Bellman-Ford algorithm.</li>
<li>Graph union, intersection, difference, several algorithms for graph similarity check.</li>
<li>BFS and DFS search of graph.</li>
<li>and more.</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Third-party code used</h1>
<p >Doxygen dark theme by MaJerle: <a href="https://github.com/MaJerle/doxygen-dark-theme">https://github.com/MaJerle/doxygen-dark-theme</a></p>
<p >String formatting by iFreilicht: <a href="https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf">https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf</a></p>
<h1><a class="anchor" id="autotoc_md5"></a>
Few notes about terms</h1>
<p >Graphs are built using Nodes (also called Vertices in literature) and weighted Edges that points from source Node to target Node. Two edges are considered identical if their source and target nodes have the same ID - weight is omitted during comparison. Nodes are identified by ID - unsigned 32bit integer. If you want to store some other datatype inside your graph, like strings, you can use externally implemented dictionary and hashing functions to do so. For any node A and B, within the graph, there can be only one edge with source node A and target node B.</p>
<p >Nodes DO NOT have to have consecutive ID numbers, I've been using such in examples only for simplicity. It's an unordered map, so ID can be any unsigned 32bit integer.</p>
<p >Internally, Graph uses unordered map, which means the order of nodes is undefined.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Brief introduction</h1>
<p >Given there's no documentation yet, I've decided to make quick instruction on how-to-use.</p>
<p >Following code generates a random graph of size 10 with density=50%, minimal weight of edge=10 and maximal=400, with loops allowed. Then, a string representation of this graph is displayed to standard output. Finally, the graph is saved to file "graph" in binary form. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    HWDG::Graph graph = HWDG::RandomLowDensityGraph(10, 0.5, 10, 400, true);</div>
<div class="line">    std::cout &lt;&lt; &quot;Generated random graph: &quot; &lt;&lt; graph.str();</div>
<div class="line">    HWDG::SaveBin(graph, &quot;graph&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Let's load previously generated graph, generate new one, and try some basic operations: union, difference, intersection </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    HWDG::Graph graph_a = HWDG::RandomGraph(10, 0.5, 10, 400, true);</div>
<div class="line">    HWDG::Graph graph_b = HWDG::LoadBin&lt;HWDG::Graph&gt;(&quot;graph&quot;);</div>
<div class="line">    std::cout &lt;&lt; &quot;Union: &quot; &lt;&lt; HWDG::Union(graph_a, graph_b).str() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; &quot;Difference: &quot; &lt;&lt; HWDG::Difference(graph_a, graph_b).str() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; &quot;Intersection: &quot; &lt;&lt; HWDG::Intersection(graph_a, graph_b, 0.5).str() &lt;&lt; std::endl;</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >And now, let's create the graph manually: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    // Creating blank graph</div>
<div class="line">    HWDG::Graph graph;</div>
<div class="line">    // Creating list of nodes (vertices)</div>
<div class="line">    HWDG::Node n[6] = { HWDG::Node(0), HWDG::Node(1), HWDG::Node(2), HWDG::Node(3), HWDG::Node(4), HWDG::Node(5) };</div>
<div class="line">    // Adding nodes to graph</div>
<div class="line">    graph.add(n[0]);</div>
<div class="line">    // It supports initializer list too</div>
<div class="line">    graph.add({ n[1], n[2], n[3], n[4], n[5] });</div>
<div class="line">    // Adding edges</div>
<div class="line">    graph.add(HWDG::Edge(n[0], n[1], 3)); // Creating edge from n[0] to n[1] with weight=3</div>
<div class="line">    graph.add({ // initializer list is supported here too</div>
<div class="line">        HWDG::Edge(n[0], n[4], 3),</div>
<div class="line">        HWDG::Edge(n[1], n[2]), // if weight isn&#39;t specified, it defaults to 1</div>
<div class="line">        HWDG::Edge(n[2], n[3], 3),</div>
<div class="line">        HWDG::Edge(n[2], n[5], 1),</div>
<div class="line">        HWDG::Edge(n[3], n[1], 3),</div>
<div class="line">        HWDG::Edge(n[4], n[5], 2),</div>
<div class="line">        HWDG::Edge(n[5], n[0], 6),</div>
<div class="line">        HWDG::Edge(n[5], n[3], 1)</div>
<div class="line">        });</div>
<div class="line">    // Getting some information</div>
<div class="line">    std::cout &lt;&lt; &quot;Density: &quot; &lt;&lt; graph.density() &lt;&lt; std::endl</div>
<div class="line">        &lt;&lt; &quot;Nodes: &quot; &lt;&lt; graph.size_nodes() &lt;&lt; std::endl</div>
<div class="line">        &lt;&lt; &quot;Edges: &quot; &lt;&lt; graph.size_edges() &lt;&lt; std::endl</div>
<div class="line">        &lt;&lt; &quot;Sum of weights: &quot; &lt;&lt; graph.weight_sum() &lt;&lt; std::endl</div>
<div class="line">        &lt;&lt; &quot;Has negative weights: &quot; &lt;&lt; graph.has_negative_weights() &lt;&lt; std::endl;</div>
<div class="line">    // Check for nodes/edges</div>
<div class="line">    std::cout &lt;&lt; &quot;Has node 3? &quot; &lt;&lt; graph.has(n[3]) &lt;&lt; std::endl</div>
<div class="line">        &lt;&lt; &quot;Has edge 2-&gt;3? &quot; &lt;&lt; graph.has(HWDG::Edge(n[2], n[3])) &lt;&lt; std::endl</div>
<div class="line">        &lt;&lt; &quot;Has edge 3-&gt;2? &quot; &lt;&lt; graph.has(HWDG::Edge(n[3], n[2])) &lt;&lt; std::endl;</div>
<div class="line">    // Saving to file in text form</div>
<div class="line">    HWDG::SaveTxt(graph, &quot;manual.txt&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Now, Dijkstra and BellmanFord algorithms. I'll use the graph from the previous example (which was saved in manual.txt) </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    HWDG::Graph graph = HWDG::LoadTxt&lt;HWDG::Graph&gt;(&quot;manual.txt&quot;);</div>
<div class="line">    try {</div>
<div class="line">        auto dijkstra_path = HWDG::Dijkstra::Compute(graph, HWDG::Node(0));</div>
<div class="line">        auto bellman_path = HWDG::BellmanFord::Compute(graph, HWDG::Node(0));</div>
<div class="line">        std::cout &lt;&lt; dijkstra_path.str() &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; bellman_path.str() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    catch (const std::invalid_argument&amp; e)</div>
<div class="line">    {</div>
<div class="line">        // This section will be triggered if graph contains negative edges</div>
<div class="line">        // or if there&#39;s negative cycle, in case of Bellman-Ford algorithm</div>
<div class="line">        std::cout &lt;&lt; &quot;Exception occured: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Traversing graph (through nodes and edges originating from each node) </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    HWDG::Graph graph = HWDG::LoadTxt&lt;HWDG::Graph&gt;(&quot;manual.txt&quot;);</div>
<div class="line">    for (const auto&amp; node : graph)</div>
<div class="line">    {</div>
<div class="line">        for (const auto&amp; edge : node)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; &quot;Traversing: &quot; &lt;&lt; node.id() &lt;&lt; &quot; - &quot; &lt;&lt; edge.str() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Traversing graph (through all edges, in undefined order) </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    HWDG::Graph graph = HWDG::LoadTxt&lt;HWDG::Graph&gt;(&quot;manual.txt&quot;);</div>
<div class="line">    for (const auto&amp; edge : graph.edges())</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; edge.str() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >You can also use <a class="el" href="namespace_h_w_d_g.html#a7b1335e550ac012515e07da6f8009032" title="Breadth First Search (BFS) of graph.">BreadthFirstSearch()</a> and <a class="el" href="namespace_h_w_d_g.html#a1397d769f1f4c8b17b46702eabc332fe" title="Depth First Search (DFS) of graph.">DepthFirstSearch()</a> to traverse graph, in slightly different manner. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    HWDG::Graph graph = HWDG::LoadTxt&lt;HWDG::Graph&gt;(&quot;manual.txt&quot;);</div>
<div class="line">    HWDG::BreadthFirstSearch(graph, HWDG::Node(3), [&amp;graph](const HWDG::Edge&amp; edge, const auto&amp; visited) {</div>
<div class="line">        HWDG::NodeInGraph current = graph.fetch(edge.target());</div>
<div class="line">        for (const auto&amp; e : current)</div>
<div class="line">        {</div>
<div class="line">            // do something with all neighbours of current node</div>
<div class="line">            // if you want to check whether node was visited...</div>
<div class="line">            auto check_if_visited = visited.find(e.target());</div>
<div class="line">            if (check_if_visited != visited.end()) // Check if target node was visited</div>
<div class="line">            { }</div>
<div class="line">            else // not visited</div>
<div class="line">            { }</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p >There's also another implementation of functions above that allows you to specify order (priority) of neighbours to follow, so you still do BFS/DFS algorithms but with more control which path within graph you follow. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;algorithm&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    HWDG::Graph graph = HWDG::RandomLowDensityGraph(100, 0.3, 100, 150, true);</div>
<div class="line">    HWDG::DepthFirstSearch(graph, HWDG::Node(3),</div>
<div class="line">        [&amp;graph](const HWDG::Edge&amp; edge, const auto&amp; set_of_visited) {</div>
<div class="line">            HWDG::NodeInGraph current = graph.fetch(edge.target());</div>
<div class="line">            std::cout &lt;&lt; edge.str() &lt;&lt; std::endl;</div>
<div class="line">        },</div>
<div class="line">        [](const HWDG::NodeInGraph&amp; node, std::vector&lt;HWDG::Edge&gt;&amp; to_be_visited, const auto&amp; set_of_visited) {</div>
<div class="line">            // add all neighbours in undefined order</div>
<div class="line">            for (const HWDG::Edge&amp; edge : node)</div>
<div class="line">            {</div>
<div class="line">                to_be_visited.push_back(edge); // no need to worry about visited/not visited, underlying algorithm will deal with it on its&#39; own</div>
<div class="line">            }</div>
<div class="line">            // sort ascending by weight</div>
<div class="line">            std::sort(to_be_visited.begin(), to_be_visited.end(), [](const auto&amp; a, const auto&amp; b) { return a.weight() &lt; b.weight(); });</div>
<div class="line">        });</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Serialization</h1>
<p >You could see in examples above <a class="el" href="namespace_h_w_d_g.html#ab908ab18cd038439108689003e4e5389" title="Load object from file in text mode.">LoadTxt()</a>, <a class="el" href="namespace_h_w_d_g.html#aed54e86d592f3e74b07a4d3d8b602e8c" title="Save object to file in text mode.">SaveTxt()</a>, <a class="el" href="namespace_h_w_d_g.html#a68635147a3ea51445f7135b194f40506" title="Load object from file in binary mode.">LoadBin()</a>, <a class="el" href="namespace_h_w_d_g.html#a72e3c48717069c9966704007b404c3ce" title="Save object to file in binary mode.">SaveBin()</a> functions. Those are wrappers for more raw functions that allow you to store most of datatypes in files (or streams). All serialization functions are written as static member functions of classes, and have no checksum control or any sanity check for loaded data, so be careful.</p>
<p >SaveTxt stores datatype with basic string representation that can be viewed in any text editor, and it's actually a viable way to create small graphs. Txt representation also works the same for any computer architecture, regardless of big endian / little endian. Downsides are: it's slower and wasteful when it comes to space.</p>
<p >SaveBin stores as little data as necessary, representing attributes with their binary form. It's fast and space efficient, but you can't even safely open such files, and it depends on computer architecture. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;fstream&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    std::ofstream txt_file; txt_file.open(&quot;serial.txt&quot;); // File to save TXT representation</div>
<div class="line">    std::ofstream bin_file; bin_file.open(&quot;serial&quot;, std::ios::out | std::ios::binary); // File to save BIN representation</div>
<div class="line"> </div>
<div class="line">    HWDG::Node node(420);</div>
<div class="line">    HWDG::Node::SaveTxt(txt_file, node); // Readable and platform-independant, but slow and spaceful way of serialization</div>
<div class="line">    HWDG::Node::SaveBin(bin_file, node); // Unreadable and platform-dependant, but fast and compact way of serialization</div>
<div class="line"> </div>
<div class="line">    HWDG::Edge edge(HWDG::Node(0), HWDG::Node(1));</div>
<div class="line">    HWDG::Edge::SaveTxt(txt_file, edge);</div>
<div class="line">    HWDG::Edge::SaveBin(bin_file, edge);</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;fstream&gt;</div>
<div class="line">#include &quot;hwdg.hpp&quot;</div>
<div class="line"> </div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    std::ifstream txt_file; txt_file.open(&quot;serial.txt&quot;);</div>
<div class="line">    std::ifstream bin_file; bin_file.open(&quot;serial&quot;, std::ios::in | std::ios::binary);</div>
<div class="line"> </div>
<div class="line">    HWDG::Node n1 = HWDG::Node::LoadTxt(txt_file);</div>
<div class="line">    HWDG::Node n2 = HWDG::Node::LoadBin(bin_file);</div>
<div class="line"> </div>
<div class="line">    HWDG::Edge e1 = HWDG::Edge::LoadTxt(txt_file);</div>
<div class="line">    HWDG::Edge e2 = HWDG::Edge::LoadBin(bin_file);</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Performance</h1>
<p >Operating on graphs is fast. All basic operations are implemented properly, with constant/linear complexity. Pathfinding algorithms are also well-implemented, with Dijkstra complexity equal nodes*ln(nodes). Below I've attached results of the performance test:</p>
<p ><img src="https://user-images.githubusercontent.com/41695668/170328332-fa909703-aaa1-4d0f-a250-e31807a516e8.png" alt="bellman" class="inline"/> <img src="https://user-images.githubusercontent.com/41695668/170328336-b6d431b6-7957-46ab-90af-294691d01677.png" alt="dijkstra" class="inline"/></p>
<p >Test were conducted for fixed amount of edges per node (100), minimal weight of edge (50) and maximal weight (500), repeated for 10 different, randomly generated graphs. Standard deviation for the Dijkstra algorithm was negligible and isn't included in the chart.</p>
<p >While time complexity of my implementation is good, space complexity is not. Here are some graph sizes I've tested: </p><pre class="fragment">20000 nodes, density 0.1 ⇾ 9.6 GB of RAM occupied
10000 nodes, density 0.2 ⇾ 5.1 GB of RAM occupied
5000 nodes, density 0.5 ⇾ 3.3 GB of RAM occupied
1000 nodes, density 1.0 ⇾ 250 MB of RAM occupied
</pre><p> This is because I'm using hashtables, not only to store nodes in the graph, but also to store edges for each node. Note that for 20k nodes and density 0.1, it still means there are 2000 edges per node, totaling to 4 M edges.</p>
<p >Within documentation, <b>all time complexity represents average case</b> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
